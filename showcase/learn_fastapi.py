# uvicron это как бы переводчик между питоном и nginx
#клиент отправляет запрос (или через сайт, мобильное приложение, постман, терминал и тд) на наш сервер
# через hhtps или http на 80 или 443 порт
#далее выступает reverse proxy сервер, чаще всего это nginx. Далее nginx передает запрос на ASGI, и ASGI передает это в наше приложение на fastapi написанное на питоне
#само приложение не умеет интегрироваться напрямую в сеть инета и ему нужны посредники, которые будут например защищать от ддос атак например, для этого нужен nginx. Но nginx не умеет работать с питоновскими приложениями. Для этого нужен uvicorn, он для взаимодействия в питоновским приложением. uvicorn асинхронный , если примерно то он переводит с питоновкого на язык nginx
#то есть прилетает запрос в nginx, он отправляет это в uvicorn, далее отправляется в наше приложение и обрабатывается какая-то логика приложения. Далее обратно по той же цепочке, fastapi--uvicorn--nginx--клиент
#fastapi основан на Starlette и Pydentic
# Starlette - ответчает за веб
# Pydentic - отвечает за сериализацию и валидацию. 
# проект у препода: платформа для обучения для студентов
#для юзеров лучше юзать uuid вместо id.
#инфа про докер есть в первом видео ост 15 мин:
# https://www.youtube.com/watch?v=UkwpJyvf8CA&list=PLlKID9PnOE5jiWTTsshCXdz5qvg8JWezX&ab_channel=luchanos
#он делает постгерс в докер файле. ВЕРНУТЬСЯ К ДОКЕРУ ПОЗЖЕ.
#немного поправил движок алхимии
#логика в добавлении пользователя:!!!!!!!!!!!!!!!!!!!!!
# он там сделал класс, это на 27 мин. В котором будет добавляться пользователь в сессию. Выглядит странно, но вроде норм. 

#также сделал базовый класс для схем pydentic и в нем прописал класс Config в котором прописал:
# orm_mode = True
#это чтобы Pydentic переводил все данные в Json, то есть в словари. Потом можно наследовать всех схемы на основе этого класса, а не BaseModel. 
# юзера валидировал как uuid.UUID в модели Pydentic, странно
#сделал еще валидаторы ФИО, чтобы должны быть только буквы в ФИО. Кажется верное решение. У меня просто name, типа логин. Мне наверно пока не надо.
#далее он валидирует роутер юзера схемой Pydentic которую он сделал для юзера
#в алембик можно писать не асинхронный psycopg2
#в постмане можно писать ссылки и тип запроса, там возвращается ответ от сервера. По сути похоже на доку фаст апи swagger. 


#АРХИТЕКТУРА АВТОРИЗАЦИИ!!!!!!!!!!!!!!!!!!!!!!!!
#клиент делает запрос к серверу и передает туда логин и пароль. Сервер отдает клиенту refresh токен через  HTTP_ONLY COOKIE, он должен быть получен только через http, и не может быть получен с помощью JS и не может быть иным способом изменен с помощью JS. Срок жизни рефреш токена долгий, зависит от масштаба проекта. Рефреш токен тоже JWT. Обычно этот токен содержит цифровой отпечаток, он содержит инфу о клиенте который сделал запрос. То есть инфа о браузере, заголовки в запросе и тд. Эту инфу нужно проверять каждый раз когда будем работать с рефреш токеном. Обновляет рефреш токен либо сам пользователь, либо сервер. Лучше если будет обновлять рефреш токен сам пользователь, введя свои логин и пароль.
#есть правило, 1 рефреш токен может обмениваться на 1 рефреш токен. 1RT --> 1RT
#Сервер содержит базу данных, которая содержит инфу о состоянии всех рефреш токенов. То есть сервер знает что происходит с каждым рефреш токеном. То есть мы можем фиксировать что какой-то токен ранее уже менялся без аутентификации - к примеру. В случае если злоумышленник получил рефреш токен и пытается его обновить, то он также не сможет это сделать (если пытается обновить, то значит знает логин и пароль). Дублей тоже не должно быть, дубли отзываются. Если злоумышленник обновил токен, потом юзер реальный тоже обновит, то новый и старый, то есть токены попадают в блеклист. И это будет дубль и тогда и новый и старый токены попадают в блек лист (черный список). Также в черный список попадают все токены, которые не прошли отпечаток пальца (отпечаток пользователя). И тогда система будет заставлять повторно пройти ауетентификацию. Хранится рефреш токен только на сервере, все что касается рефреш токена - это взаимодействие с сервером авторизации. Нигде более он не должен отображаться, только на сервере. Он нужен для определения кем пользователь является.
#Также есть access токены. Их можно получить только имея действующий рефреш токен. 
#сначала мы проходим авторизацию, при обращении к какому либо защищенному методу на сервере создается рефреш токен и передается пользаку, либо проверяется инфа, что это мы через рефреш токен - сверяется отпечаток и тд, и если все верно, то сервер выдает пользователю токен доступа - access token. Срок действия access токена от нескольких минут до 1 дня. Токен доступа нельзя отозвать, даже если он скомпрометирован, то есть украден. Время действия acces token (JWT) маленькое. Инфа в JWT access токене должна быть максимально короткая, достаточная для того, чтобы наше приложение могло определить что это нужный нам пользователь. Пользак передает JWT и сервер приложение наше возвращает нужные данные. Хранится JWT в памяти клиента, то есть или куки или ОЗУ локальном хранилище вкладки. Если он закроет вкладку или браузер, ему заново надо получить access token. Для разных сервисов может использоваться разные токены. Также jwt токены это не самый лучший способ защиты данных. Например в банках такая структура может не подойти. Лучше не юзать jwt в банках.
# Если истекает рефреш токен, то нужно заново залогиниться.
#основная идея jwt токена это разгрузить сервер, чтобы каждый раз не генерировать токены, а передать их клиенту, и чтобы он мог работать с ними. Есть недостаток, если токен доступа украден, то нужно дождаться пока он истечет. В случае если в момент работы юзера его токен украден, то в сервисе нужно вывести уведомление, о том что токен украден. Сделать ничего нельзя, так как токен будет на стороне злоумышленника, и его нельзя у него отобрать. Есть только один способ, это изменить ключ секрет, с которым идет шифрование аксес токена. Но также можно сделать кнопку для отзыва рефреш токена, тогда если его украли, то можно его отозвать (или поместить в черный список) со всех устройств. Потом сменить пароль и тд. Можно для разных функций еще делать отдельные аксес токены, тогда при утере одного токена, другие функции не пострадают. Тоже самое с рефреш токенами. Также это можно юзать с микросервисами, когда есть какие-то короткие транзакции, можно юзать короткие jwt токены.




# рефреш токен реже юзается, и юзается только для обновления аксеса

# если будет только аксес, то он будет постоянно юзаться, и есть больший шанс что украдут, время действия большое, если украдут, то будут долго пользоваться. Как сделать проверку на подлинность аксеса?




# https://habr.com/ru/companies/doubletapp/articles/764424/

#сделал, работает и время само по себе валидируется, если срок истекает, то пишет ошибку. !!!!!!!!!!!!!

# ###########################################################
# #функция поиска записи юзера в таблице токенов по токену. Находится запись по токену, в ней есть инфа о пользователе которому принадлежит токен и возвращаем юзера владеющего токеном или иначе исключение. Обратиться в пользователю мы можем из-за того что есть relationship в модели, то есть ссылка на юзера, очень удобно. Скорее всего это надо сделать роутером или как то юзать в html-ках для првоерки авторизации. Также нужно сделать jwt токен вместо обычного uuid, и сделать ему время жизни
# async def get_user_by_token(acces_token: str, session: AsyncSession = Depends(get_async_session)):
#     token = await session.scalar(select(Token).where(Token.acces_token == acces_token))
#     if token:
#         return { "id": token.user.id, "email": token.user.email }
#         # return True
#     else:
#         raise HTTPException(
#             status_code=HTTP_401_UNAUTHORIZED,
#             detail="UNAUTHORIZED"
#         )
# ############################################################


#SQLAlchemy №9. Relationships. Виды связей, стратегии загрузки. 
#связь один к одному
#например муж и жена
#связь один к многим
#например 1 учитель и у него много учеников
#связь многие ко многим
#например семья 2 родителя и 3 ребенка, у каждого ребенка 2 родителя и у каждого родителя есть три ребенка
#при реализации связей многие ко многим тут потребуется таблица ассоциаций, без нее нельзя. То есть это второстепенная таблица такая для связи многие ко многим. 
#связь такая:
# первая таблица --> связь один ко многим --> второстепенная таблица --> связь один ко многим --> вторая таблица
# При нормализированной форме таблиц организовать связь многие ко многим нельзя. нужноа будет второстепенная таблица.
#связь пользователя и емейл например это связь one to one - один к одному.
# пример связи один к одному:
#
# class Payment(Base):
#     __tablename__ = "payment"
#     id: Mapped[int] = mapped_column(unique=True, primary_key=True)
#     pay: Mapped[Pay] = mapped_column(nullable=False)#тут будет выбор нал или безнал из класса Pay, там указаны перечисления
#     pay_for_contact: Mapped["Contacts"] = relationship(back_populates="pay", uselist=False)#важно прописать uselist=False в relationship
#
# class Contacts(Base):
#     __tablename__ = "contacts"
#     id: Mapped[int] = mapped_column(primary_key=True)
#     # user = Column(Integer, ForeignKey(".id"))
#     fio: Mapped[str] = mapped_column(nullable=False)
#     phone: Mapped[int] = mapped_column(default=0)
#     delivery_address: Mapped[str] = mapped_column(default="_")
#     pay_id: Mapped[int] = mapped_column(ForeignKey("payment.id"))
#     pay: Mapped["Payment"] = relationship(back_populates="pay_for_contact", uselist=False)

# oplata = Payment(id=1, pay="нал")
# contakt = Contacts(id=1, fio="Сидоров", phone="123", delivery_address="сюда")
# #Создали 2 объекта для записи в базу. При такой связи можно обратиться и присвоить значение так:
# contakt.pay = oplata

#обратиться можно тут к объекту оплаты можно через объект контакта. Но тогда будет юзаться 2 sql запроса, то есть таблица контактов запросится, потом оплаты

#Пример связи 1 ко многим

# class Payment(Base):
#     __tablename__ = "payment"
#     id: Mapped[int] = mapped_column(unique=True, primary_key=True)
#     pay: Mapped[Pay] = mapped_column(nullable=False)#тут будет выбор нал или безнал из класса Pay, там указаны перечисления
#     pay_for_contact: Mapped["Contacts"] = relationship(back_populates="pay", uselist=False)#важно прописать uselist=False в relationship
#
# class Contacts(Base):
#     __tablename__ = "contacts"
#     id: Mapped[int] = mapped_column(primary_key=True)
#     # user = Column(Integer, ForeignKey(".id"))
#     fio: Mapped[str] = mapped_column(nullable=False)
#     phone: Mapped[int] = mapped_column(default=0)
#     delivery_address: Mapped[str] = mapped_column(default="_")
#     pay_id: Mapped[int] = mapped_column(ForeignKey("payment.id"))
#     pay: Mapped[list["Payment"]] = relationship(back_populates="pay_for_contact", uselist=True)#то тут поставили тру, как будто у каждого контакта может быть список оплат. Также прописали аннтацию Mapped[list["Payment"]]


# пример связи многие ко многим

# class Payment(Base):
#     __tablename__ = "payment"
#     id: Mapped[int] = mapped_column(unique=True, primary_key=True)
#     pay: Mapped[Pay] = mapped_column(nullable=False)#тут будет выбор нал или безнал из класса Pay, там указаны перечисления
#     pay_for_contact: Mapped[list["Contacts"]] = relationship(back_populates="pay", uselist=True, secondary="contacts_payment")#и в первой и второй таблице прописали True, то есть и там и там будет список значений. Также указали secondary, это второстепенная таблица
#
# class Contacts(Base):
#     __tablename__ = "contacts"
#     id: Mapped[int] = mapped_column(primary_key=True)
#     # user = Column(Integer, ForeignKey(".id"))
#     fio: Mapped[str] = mapped_column(nullable=False)
#     phone: Mapped[int] = mapped_column(default=0)
#     delivery_address: Mapped[str] = mapped_column(default="_")
#     #pay_id: Mapped[int] = mapped_column(ForeignKey("payment.id"))# получается тут уже не юзается форинкей, а создается отдельная таблица то есть класс
#     pay: Mapped[list["Payment"]] = relationship(back_populates="pay_for_contact", uselist=True, secondary="contacts_payment")

# class ContactsPayment(Base):
#     __tablename__ = "contacts_payment"
#     pay_fk: Mapped[int] = mapped_column(ForeignKey("payment.id"))#для таблицы контактов
#     contact_fk: Mapped[int] = mapped_column(ForeignKey("contacts.id"))#для таблицы оплаты

#есть стратегии загрузки их нужно писать в параметре lazy в relationship, "selectin" и "joined". В случае с joined выдается присоединенная таблица в случае если настроили связь, если selectin то присоединеная таблица выводится отдельно.

#core в алхимии это запросы без ОРМ, работают на много быстрее чем ОРМ запросы. УТочнить потом что такое core
#если объектов не очень много лучше юзать joined, если объектов очень много то лучше юзать subquery как параметр для lazy. Вобщем в основном joined юзать.
#посмотреть шумейко, может еще что-то скажет и пересмотреть текущее видео массона




# Курс шумейко по алхимии!!!!!!!
# SQLAlchemy: Создание таблиц и вставка данных через Core #3!!!!!!!!!!!

#сырые запросы можно оборачивать в функцию text в алхимии. text можно импортировать из алхимии
#к базе нужно сначала подключаться через движок и потом через подключение через функцию execute отправлять запросы. ПОдключение через менеджер конектста делать with. Если делать не через алембик, в алхимии можно создавать и удалять таблицы через объект метадаты, в случае если используется императивный стиль. После отправки данных их нужно коммитить
#вставка в императивном стиле не асинхронно:
# insert("имя таблицы").values(список словарей для вставки в таблицу)
# такие запросы при ииспользовании execute не нужно оборачивать в text()
#ПС - сырые запросы на SQL работают быстрее! Но на питоне запросы читаются на много легче

# SQLAlchemy: Session и первые шаги в ORM #4!!!!!!!!!!!
#когда открывается сессия, то в итоге делается либо коммит либо rollback, то есть данные либо попадают в БД либо нет
#если бы не было sessionmaker то приходилось через with каждый раз открывать сессию и потом делать запросы. И движок везде передавать придется, и параметры указывать. Удобнее 1 раз создать sessionmaker, записать его в отдельную переменную и потом юзать его везде с уже прописанными нужными нам параметрами. И конечно есть асинк версия и не асинк версия.
#шумейко юзал просто класс DeclarativeBase, и от него наследовался. я сделал переменную и в нее записал функцию declarative_base
#при создании модели можно не писать mapped_column если в него ничего передавать не надо
#есть функция add и add_all они добавляют из сессии объекты, соответственно 1 объект и список объектов. Объект это строка в БД будет. В чем разница с execute не понятно, вроде execute не работает на декларативный стиль, но также добавляет что в сессию, и с ним вроде нужен await. Перед add не надо писать await, потому что данные никуда не отправляются, и данные храняться в ОЗУ. То есть await нужно писать только когда что-то отправляем куда-то. Можно запускать режим дебага в пайчарме и расставить точки на нужных пунктах, так видно когда что-то отправляется, а когда нет. echo=True не забыть прописать в движке алхимии. 
#!!!!!!!!!!как вызвать асинхронную функцию: asyncio.run(имя функции()) !!!!!!!!!!

# SQLAlchemy: Создание таблиц через КЛАССЫ - Mapped и mapped_column #5!!!!!!!!!!!!!!
#название таблиц моделей можно называть во множественном числе, разницы особой нет, главное чтобы все было в одном стиле, чтобы хорошо выглядело и аккуратно. 
#указание что поле может быть пустым
#mapped_column(nullable=True)
# или
#pole: Mapped[int | None]#то есть может быть int или None
#pole: Mapped[Optional[int]]#это тоже самое
#можно в типе указать перечисления. Для этого нужно создать отдельынй класс и наследовать его от enum.Enum. 
#потом в Mapped[тут указать класс с перечислениями]. Тогда в базе можно будет выбрать параметр из списка перечислений. В классе перечислений просто написать переменные со значениями, например a = "синий", b = "красный", тогда можно значние в поле будет выбрать синий или красный. 
#как указать ForeignKey - вторичный ключ. ForeignKey("название таблицы.первичный ключ"). Обычно пишут в кавычках, тогда алхимия будет сама подтягивать из разных файлов модели, если написать не в кавычках название класса и поля через точку, тогда нужен будет импорт модели из другого файла, так сложнее. Но лучше все протестить.
#параметр ondelete, влияет на то что будет если удалить таблицу на которую ссылается форинкей. Например есть таблица работников, и есть таблица резюме работников, если удалить работника то удалятся все его резюме. Подразумевается что параметр ondelete будет в форинкей таблицы резюме. То есть резюме ссылается на работника, и если удалить работнка, то каскадно удаляются все его резюме. 
#для полей с датой можно указывать тип datetime из модуля datetime в классе Mapped
#в mapped_column можно указать или просто default или server_default. default это будет питон присваивать то есть на уровне приложения присвоение будет идти, а server_default это на уровне СУБД будет присвоение. 
#можно писать server_default=func.now() будет присовено время часового пояса сервера БД. 
#или можно прописать server_default=text("TIMEZONE('utc', now())"), тогда будет присвоено время по часового поясу. Нужно тестить, пока не понятно. Запросы из ОРМ могут быть не очень эффективными, сырые запросы быстрее работают. В SQL есть какие-то триггеры для обновления полей update, это поле в котором может быть указано время обновления этой записи, то есть время изменения. В наше случае можно в mapped_column прописать поле onupdate=datetime.datetime.utcnow без скобок. Если прописать скобки то будет один и тот же отпечаток времени заноситься. 
#можно еще делать кастомные типы для Mapped. Например для id сделать тип и не прописывать каждый раз mapped_column. Или вынести отдельно типы для полей со временем создания и обновления. Для этого можно юзать класс Annotated. 
#пример:
# intpk = Annotated[int, mapped_column(primary_key=True)]
# created_at = Annotated[datetime.datetime, mapped_column(server_default=text("TIMEZONE('utc', now())"))]
# updated_at = Annotated[datetime.datetime, mapped_column(
#         server_default=text("TIMEZONE('utc', now())"),
#         onupdate=datetime.datetime.utcnow,
#     )]
#теперь можно просто прописать например id: Mapped[intpk] и этого достаточно для указания поля id.
#можно еще ограничить длинну строки
# title: Mapped[str] = mapped_column(String(256))#будет ограничение 256 символов
#можно создать тип внутри класса Base от которого наследуемся с таким внутренним типом для строк. 
#можно также юзать функцию для создания таблиц и удаления через класс Base. 
# Например Base.metadata.drop_all()
# Или Base.metadata.create_all()

# SQLAlchemy: SELECT и UPDATE запросы через ORM и Core #6!!!!!!!!!!!!!
#в видосе есть инфа как делать кор и орм запросы, не вдавался в подробности пока. Если что можно будет вернуться. 
# bindparams защищает от sql инъекций в сырых запросах sql
#но можно юзать функциию питона из алхимии. 
#orm
#session.get(Модель, значение параметра для поиска строки из БД)
#можно указывать и словарь или кортеж. Но это поиск только 1 строки.
#для поиска нескольких строк нужен метод select
# пример
# def select_workers():
#         with session_factory() as session:#открыли сессию
#             query = select(WorkersOrm)#выделили таблицу
#             result = session.execute(query)#сделали запрос
#             workers = result.scalars().all() #запросили всех из таблицы
# это 1 запрос. Возвращаться тут будет список объектов. Из них можно обращаться к полям

# функция для обновления одного работника с помощью функциии get. мы его просто выделяем и изменяем ему свойство объекта на новое значение
# def update_worker(worker_id: int = 2, new_username: str = "Misha"):
#         with session_factory() as session:
#             worker_michael = session.get(WorkersOrm, worker_id)
#             worker_michael.username = new_username
#             # refresh нужен, если мы хотим заново подгрузить данные модели из базы.
#             # Подходит, если мы давно получили модель и в это время
#             # данные в базе данныхмогли быть изменены
#             session.refresh(worker_michael)
#             session.commit()

# при обновлении поля в базе через орм делается 2 sql запроса - получаем объект и потом обновляем объект, но можно написать такой же запрос на языке sql, это будет более производительнее и эффективнее. 

#функция flush она отправляет изменения в бд но не завершает работу с бд, то есть не завершает транзакцию. А commit тоже отправляет изменения в бд и завершает работу с бд. Это может понадобится когда мы создаем работника и еще не отправили в бд инфу и создаем резюме работника по его ИД, и чтобы ИД появлся нужен flush, и тогда у нас создается и работник и резюме сязанное с ним и сразу коммитится в бд 2 таблицы получается. 

# функция expire отменяет одно изменения которые мы делали в нашей функции update например. expire_all отменяет все изменения. И тогда запрос в бд при коммите ничего не отправит и sql запросов не будет.
#но можно и юзать refresh - эта функция обновляет в запущенной программе данные из БД и если мы их изменили но не закоммитили и сделали рефреш, то они запросятся из бд sql запросом и если далее будет идти коммит, то изменений не произойдет. Иногда бывает полезно. 

# SQLAlchemy: Базовые SELECT запросы #7
# select().filter()#это тоже самое что и where
# select().where()#тут могут быть разнгые условия, больше меньше и тд
# select().filter_by()#что-то равно чему-то
# # сгруппировать питонистов по рабочей нагрузке, и посмотреть в среднем сколько они просят денег
# example_query = select(ResumesOrm.workload,func.avg(ResumesOrm.compensation).cast(Integer).label("avg_compensation")).filter(and_(
# 		модель.поле.contains(параметр),#contains это типа содержит что-то
# 		модель.поле > 100#это для примера
# 		).group_by(модель.поле)#группировка по какому либо полю
# 		.having(func.avg(ResumesOrm.compensation) > 70000#func из алхимии импортировать
# )#2 условия, функция and_ импортируется из алхимии, в скобках передаем условия


# SQLAlchemy: Введение в RELATIONSHIP - вся МОЩЬ ORM #9
# релейшншип делать также в двух таблицах и форинкей только в одной. 

# есть проблема когда делаем запрос в бд все таблицы, потом берем поле отдельной строки, то на каждую строку будет отдельный запрос sql (n+1), это плохо
# но есть ситуации когда мы подгружаем таблицу и когда отдельное поле может не понадобиться, а может и понадобиться

# пример joinedload запрос

# def select_workers_with_joined_relationship():
#         with session_factory() as session:
#             query = (
#                 select(WorkersOrm)
#                 .options(joinedload(WorkersOrm.resumes))
#             )
            
#             res = session.execute(query)
#             result = res.unique().scalars().all()

#             worker_1_resumes = result[0].resumes
#             print(worker_1_resumes)
            
#             worker_2_resumes = result[1].resumes
#             print(worker_2_resumes)

#при таком join запросе, sql запрос делается 1, и потом из него просто берутся поля нужны уже присоединенные, и дополнительных sql запросов не делается.
# проблема такой загрузки, в том, что при выгрузке таблицы 1 ко многим, будет дублироваться данные из первой таблицы по колву связанных записей из второй. Напримр у одного работника много резюме, и в запросе будет несколько резюме и напротив каждого может быть один и тот же работник. 
# joined подходит или для многие к одному или один к одному. у меня товары многие к одному, то есть товара - свойство группа, а не у группы свойство - товар. !!!!!!!!!!!!!!!!!!!!!!!
# есть еще стратегия selectin - она подходит к многие ко многим и к один ко многим. !!!!!!!!!!!!!!!!!!!!!!!!


#метод для изменения вывода на печать моделей. его прописать лучше в базовом классе от которого наследуются модели другие. в наследуемых классах моделей модно переоопределять поля repr_cols_num и repr_cols, тогда на печать будет выводиться по другому

# repr_cols_num = 3
# repr_cols = tuple()
# def __repr__(self):
#         """Relationships не используются в repr(), т.к. могут вести к неожиданным подгрузкам"""
#         cols = []
#         for idx, col in enumerate(self.__table__.columns.keys()):
#             if col in self.repr_cols or idx < self.repr_cols_num:
#                 cols.append(f"{col}={getattr(self, col)}")

#         return f"<{self.__class__.__name__} {', '.join(cols)}>"

# ленивая подгрузка не работает в Relationships в асинхронном варианте. ТО есть нельзя обратитья к связанному полю из запрошенной таблицы, нужно делать join или selected запросы и тогда все норм. 

# SQLAlchemy: Продвинутые relationship + индексы и constraints на уровне БД #10

# в relationship нужно прописывать параметр back_populates. В нем пишем поле из связанной таблицы с relationship
# еще есть параметр backref, это по сути аналог back_populates. Это по сути неявное указание на другую relationship, то есть если в другой модели не указать relationship, то backref все равно будет ссылаться на другую таблицу, как будто там прописан relationship. Кажется прикольно. Но так делать не стоит, так как это устаревшая техноголия, и лучше явно писать relationship back_populates в обеих моделях. 

# Если есть таблица автор, и есть таблица статей автора, у автора будет много статей. И нам не нужно их все грузить сразу.
# Для этого в relationship есть параметр primaryjoin
# пример. primaryjoin="and_(WorkersOrm.id == ResumesOrm.worker_id, ResumesOrm.workload == 'parttime')"
#в примере выводим резюме с временем работы "parttime"
# в кавычках пишется sql запрос или несколько запросов в одном с объединением and_
#теперь к нему можно сделать запрос, пример: 
# def select_workers_with_condition_relationship():
#         with session_factory() as session:
#             query = (
#                 select(WorkersOrm)
#                 .options(selectinload(WorkersOrm.resumes_parttime))#запрос резюме с параметром parttime/ Важно сам объект резюме тут не подгружается, а только связь с ним. И объект подгрузиться отдельным запросом когда мы к нему обратимся.
#             )

#             res = session.execute(query)
#             result = res.scalars().all()
#             print(result)
# в relationship есть еще параметр lazy. В нем можно указать как будет происходить подгрузка. Этот параметр лучше писать в самом запросе, а не в relationship. Так как если прописать в relationship, то все запросы будут подгружаться так как мы это пропишем в relationship, а может быть нам нужно будет по другому это сделать. 

# contains_eager!!!!!!!

# query = (
# select(WorkersOrm)
# .join(WorkersOrm.resumes)# простой join
# .options(contains_eager(WorkersOrm.resumes))#будет подтянута вторая таблица как вложенная структура, а не табличная
# .filter(ResumesOrm.workload == "parttime")#сделали еще фильтр
# )
#чтобы сделать лимит запросов можно прописать функцию limit()
# есть еще функция in_, можно ее юзать в запросах
# in_(тут пишем уже подгруженный другой запрос или что-то еще)
# пример запроса
# query = (
#                 select(WorkersOrm)
#                 .join(ResumesOrm, ResumesOrm.id.in_(subq))
#                 .options(contains_eager(WorkersOrm.resumes))
#             )

# в моделях можно прописывать параметры в атрибуте __table_args__. То есть различные первичные ключи или вторичные ключи типа форинкей и тд. Но кючи лучше оставлять в таблице как обычно, а в параметр __table_args__ можно прописывать какие то индексы констрейнты и тд. констрейнты это различные условия которым должно соответствовать поле, также в констрейнты можно создать имя поля в БД. С индексами пока не разобрался. 
# Пример:
# __table_args__ = (
#         Index("title_index", "title"),
#         CheckConstraint("compensation > 0", name="checl_compensation_positive"),
#     )
# можно еще делать несколько первичных ключей. Подходит для связей многие ко многим

# SQLAlchemy: Pydantic DTO и FastAPI + SQLAlchemy #11!!!!!!!!!!!!!!!
# в пайдентик лучше делать для одной и тоже модели 2 класса, сначала для пост, потом наследоваться от нее для гет запроса. Например первая для добавления данных, вторая для получения данных
# пайдентик приводит данные к нужному типу данных. Можно ответ от запроса алхимии перевести в нужный тип данных. Например у нас приходят какие-то поля и мы можем их привести в json автоматом. 






# Запросы CRUD в sqlalchemy!!!!!!!!!!!!!!!!
# https://www.youtube.com/watch?v=KWu_RyTKh1s&t=3269s&ab_channel=%D0%A1%D1%83%D1%80%D0%B5%D0%BD%D0%A5%D0%BE%D1%80%D0%B5%D0%BD%D1%8F%D0%BD

# async def get_products(session: AsyncSession) -> list[Product]:
# делаем выражение statement для запроса всех товаров с сортировкой по id. 
# stmt = select(Product).order_by(Product.id)#select выделяем таблицу Product, order_by - сортировка по id модели Product. select возвращает tuple из одного элемента, но в скобках select можно написать и еще другое поле из этой таблицы, например id, тогда будет возвращен tuple из 2 объектов. 
# теперь это выражение выполняем
# result: Result = await session.execute(stmt)  #Result - это результат движка алхимии engine. execute - означает выполнить выражение, выражение у нас stmt. Сессия будет передана через зависимость Depends.
# products = result.scalars().all()#результат мы получаем через scalars().all(). scalars означает получить скалярные значения. Если в select будет tuple из двух объектов, тогда scalars нельзя юзать и можно писать только функцию all(), но в нашем случае можно юзать scalars. scalars превращает tuple в объекты Product так как нам нужны именно объекты модели Product, а функция all() превратит генератор в список из объектов модели. Также можно типы самому подгонять как хотим. 

# !!!!!!!!!!!!!!!!!!!
#то есть сначала готовим sql запрос с помощью select и тд, потом выполняем через execute или scalars, или и то и другое execute и scalars. До execute или scalars не выполняется, а только подготавливается
# !!!!!!!!!!!!!!!!!!!


# Теперь функция для запроса товара по его id
async def prod_query(session, product_id):
	return await session.get(Product, product_id)#возвращается из сессии товар по его id


# создание нового объекта - продукта
async def create_product(session, product_in: ProductCreate):#ProductCreate - это схема пайдентика для валидации, если что-то не так будет выдаваться исключение
	product = Product(**product_in.model_dump())#тут создали объект Product то есть товара, параметры для объекта мы берем из словаря product_in и распаковываем для нужных полей. Можно создавать его и просто по полям без распаковок словарей. 
	session.add()#добавили объект в сессию. 
	await session.commit()#сохранили объект в базу, закоммитили
	await session.refresh()#лучше обновлять данные из базы, так как они могут переиспользоваться и могут быть не актуальны.
	return product#тут возвращаем продукт, но можно возвращать то что нужно по ситуации


# пайдентик хорошо превращает данные в json словари. То есть крутой конвертатор
#если кидаем строку в виде ссылки то нужна валидация в str. Бывает ошибки выдаются













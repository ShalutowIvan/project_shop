# uvicron это как бы переводчик между питоном и nginx
#клиент отправляет запрос (или через сайт, мобильное приложение, постман, терминал и тд) на наш сервер
# через hhtps или http на 80 или 443 порт
#далее выступает reverse proxy сервер, чаще всего это nginx. Далее nginx передает запрос на ASGI, и ASGI передает это в наше приложение на fastapi написанное на питоне
#само приложение не умеет интегрироваться напрямую в сеть инета и ему нужны посредники, которые будут например защищать от ддос атак например, для этого нужен nginx. Но nginx не умеет работать с питоновскими приложениями. Для этого нужен uvicorn, он для взаимодействия в питоновским приложением. uvicorn асинхронный , если примерно то он переводит с питоновкого на язык nginx
#то есть прилетает запрос в nginx, он отправляет это в uvicorn, далее отправляется в наше приложение и обрабатывается какая-то логика приложения. Далее обратно по той же цепочке, fastapi--uvicorn--nginx--клиент
#fastapi основан на Starlette и Pydentic
# Starlette - ответчает за веб
# Pydentic - отвечает за сериализацию и валидацию. 
# проект у препода: платформа для обучения для студентов
#для юзеров лучше юзать uuid вместо id.
#инфа про докер есть в первом видео ост 15 мин:
# https://www.youtube.com/watch?v=UkwpJyvf8CA&list=PLlKID9PnOE5jiWTTsshCXdz5qvg8JWezX&ab_channel=luchanos
#он делает постгерс в докер файле. ВЕРНУТЬСЯ К ДОКЕРУ ПОЗЖЕ.
#немного поправил движок алхимии
#логика в добавлении пользователя:!!!!!!!!!!!!!!!!!!!!!
# он там сделал класс, это на 27 мин. В котором будет добавляться пользователь в сессию. Выглядит странно, но вроде норм. 

#также сделал базовый класс для схем pydentic и в нем прописал класс Config в котором прописал:
# orm_mode = True
#это чтобы Pydentic переводил все данные в Json, то есть в словари. Потом можно наследовать всех схемы на основе этого класса, а не BaseModel. 
# юзера валидировал как uuid.UUID в модели Pydentic, странно
#сделал еще валидаторы ФИО, чтобы должны быть только буквы в ФИО. Кажется верное решение. У меня просто name, типа логин. Мне наверно пока не надо.
#далее он валидирует роутер юзера схемой Pydentic которую он сделал для юзера
#в алембик можно писать не асинхронный psycopg2
#в постмане можно писать ссылки и тип запроса, там возвращается ответ от сервера. По сути похоже на доку фаст апи swagger. 


#АРХИТЕКТУРА АВТОРИЗАЦИИ!!!!!!!!!!!!!!!!!!!!!!!!
#клиент делает запрос к серверу и передает туда логин и пароль. Сервер отдает клиенту refresh токен через  HTTP_ONLY COOKIE, он должен быть получен только через http, и не может быть получен с помощью JS и не может быть иным способом изменен с помощью JS. Срок жизни рефреш токена долгий, зависит от масштаба проекта. Рефреш токен тоже JWT. Обычно этот токен содержит цифровой отпечаток, он содержит инфу о клиенте который сделал запрос. То есть инфа о браузере, заголовки в запросе и тд. Эту инфу нужно проверять каждый раз когда будем работать с рефреш токеном. Обновляет рефреш токен либо сам пользователь, либо сервер. Лучше если будет обновлять рефреш токен сам пользователь, введя свои логин и пароль.
#есть правило, 1 рефреш токен может обмениваться на 1 рефреш токен. 1RT --> 1RT
#Сервер содержит базу данных, которая содержит инфу о состоянии всех рефреш токенов. То есть сервер знает что происходит с каждым рефреш токеном. То есть мы можем фиксировать что какой-то токен ранее уже менялся без аутентификации - к примеру. В случае если злоумышленник получил рефреш токен и пытается его обновить, то он также не сможет это сделать (если пытается обновить, то значит знает логин и пароль). Дублей тоже не должно быть, дубли отзываются. Если злоумышленник обновил токен, потом юзер реальный тоже обновит, то новый и старый, то есть токены попадают в блеклист. И это будет дубль и тогда и новый и старый токены попадают в блек лист (черный список). Также в черный список попадают все токены, которые не прошли отпечаток пальца (отпечаток пользователя). И тогда система будет заставлять повторно пройти ауетентификацию. Хранится рефреш токен только на сервере, все что касается рефреш токена - это взаимодействие с сервером авторизации. Нигде более он не должен отображаться, только на сервере. Он нужен для определения кем пользователь является.
#Также есть access токены. Их можно получить только имея действующий рефреш токен. 
#сначала мы проходим авторизацию, при обращении к какому либо защищенному методу на сервере создается рефреш токен и передается пользаку, либо проверяется инфа, что это мы через рефреш токен - сверяется отпечаток и тд, и если все верно, то сервер выдает пользователю токен доступа - access token. Срок действия access токена от нескольких минут до 1 дня. Токен доступа нельзя отозвать, даже если он скомпрометирован, то есть украден. Время действия acces token (JWT) маленькое. Инфа в JWT access токене должна быть максимально короткая, достаточная для того, чтобы наше приложение могло определить что это нужный нам пользователь. Пользак передает JWT и сервер приложение наше возвращает нужные данные. Хранится JWT в памяти клиента, то есть или куки или ОЗУ локальном хранилище вкладки. Если он закроет вкладку или браузер, ему заново надо получить access token. Для разных сервисов может использоваться разные токены. Также jwt токены это не самый лучший способ защиты данных. Например в банках такая структура может не подойти. Лучше не юзать jwt в банках.
# Если истекает рефреш токен, то нужно заново залогиниться.
#основная идея jwt токена это разгрузить сервер, чтобы каждый раз не генерировать токены, а передать их клиенту, и чтобы он мог работать с ними. Есть недостаток, если токен доступа украден, то нужно дождаться пока он истечет. В случае если в момент работы юзера его токен украден, то в сервисе нужно вывести уведомление, о том что токен украден. Сделать ничего нельзя, так как токен будет на стороне злоумышленника, и его нельзя у него отобрать. Есть только один способ, это изменить ключ секрет, с которым идет шифрование аксес токена. Но также можно сделать кнопку для отзыва рефреш токена, тогда если его украли, то можно его отозвать (или поместить в черный список) со всех устройств. Потом сменить пароль и тд. Можно для разных функций еще делать отдельные аксес токены, тогда при утере одного токена, другие функции не пострадают. Тоже самое с рефреш токенами. Также это можно юзать с микросервисами, когда есть какие-то короткие транзакции, можно юзать короткие jwt токены.




# рефреш токен реже юзается, и юзается только для обновления аксеса

# если будет только аксес, то он будет постоянно юзаться, и есть больший шанс что украдут, время действия большое, если украдут, то будут долго пользоваться. Как сделать проверку на подлинность аксеса?




# https://habr.com/ru/companies/doubletapp/articles/764424/

#сделал, работает и время само по себе валидируется, если срок истекает, то пишет ошибку. !!!!!!!!!!!!!

# ###########################################################
# #функция поиска записи юзера в таблице токенов по токену. Находится запись по токену, в ней есть инфа о пользователе которому принадлежит токен и возвращаем юзера владеющего токеном или иначе исключение. Обратиться в пользователю мы можем из-за того что есть relationship в модели, то есть ссылка на юзера, очень удобно. Скорее всего это надо сделать роутером или как то юзать в html-ках для првоерки авторизации. Также нужно сделать jwt токен вместо обычного uuid, и сделать ему время жизни
# async def get_user_by_token(acces_token: str, session: AsyncSession = Depends(get_async_session)):
#     token = await session.scalar(select(Token).where(Token.acces_token == acces_token))
#     if token:
#         return { "id": token.user.id, "email": token.user.email }
#         # return True
#     else:
#         raise HTTPException(
#             status_code=HTTP_401_UNAUTHORIZED,
#             detail="UNAUTHORIZED"
#         )
# ############################################################


#SQLAlchemy №9. Relationships. Виды связей, стратегии загрузки. 
#связь один к одному
#например муж и жена
#связь один к многим
#например 1 учитель и у него много учеников
#связь многие ко многим
#например семья 2 родителя и 3 ребенка, у каждого ребенка 2 родителя и у каждого родителя есть три ребенка
#при реализации связей многие ко многим тут потребуется таблица ассоциаций, без нее нельзя. То есть это второстепенная таблица такая для связи многие ко многим. 
#связь такая:
# первая таблица --> связь один ко многим --> второстепенная таблица --> связь один ко многим --> вторая таблица





# тут деалем связь с таблицей групп, чтобы можно было обратиться к объекту группы. То есть чтобы у нас появилась такая связь, чтобы у нас name_group была объектом класса Group, то есть строкой таблицы group, нам нужно прописать relationship(back_populates="groups") и обязательно также указать Column(Integer, ForeignKey("group.id")), то есть нужен вторичный ключ ForeignKey и relationship с названием таблицы для связи. 







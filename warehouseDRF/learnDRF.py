#1. Django REST Framework - что это такое | Уроки по Django REST Framework!!!!!!!!!!!!!!!!!!
#drf это дополнение для джанго. нужно чтобы можно было делать запросы с других серверов к приложению на drf.
#rest это архитектурный стиль взаимодействия между клиентом и сервером. описание способа взаимодействия между клиентом и сервером
#на стороне сервеа создается программный интерфейс API.
#DRF это интрумент для создания апи нашего сайта.
#например стороннее приложение делает get запрос к сайту на DRF у какому то урл этого сайта то есть по ссылке. Сайт создает данные по этому апи запросу и отдает ответ клиенту обычно в виде JSON формате. То есть приложение отправило запрос по ссылке, и получило ответ в виде сырых данных в формате JSON. Потом приложение обрабатывает данные и отображает то что ему нужно. 
#в DRF есть CRUD, валидация, авторизация и регистрация юзеров, права доступа к данным через апи.
# схема работы
#приходит апи запрос то есть ссылка из браузера это запрос --- далее маршрутизатор отправляет в обработку этот запрос тому представлению, которое связано с этим запросом, представления обрабатывают запросы и отправляют результат пользователю в виде страницы или просто сырые данные в зависимости от потребности --- далее запрос идет к сериализаторам, они обрабатывают данные, например берут данные из бд и отправляют пользаку в виде JSON например, или сериализатор может удалить или изменить данные.

#2. Установка Django Rest Framework | Уроки по Django REST Framework!!!!!!!!!!!!!!!!!!!!!!

#команда установки такая же как в обычном джанго
#pip install django
#команда старт проекта такая же как в обычном джанго
# django-admin startproject ACCOUNTING
#запуск сервера такой же
#миграции
#python manage.py migrate
#создание приложения
#python manage.py startapp название приложения
#в сеттинг нужно подключить приложение в списке INSTALLED_APPS
#модели частино скопировал
#создание миграций!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#python manage.py makemigrations
#сама миграция!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# python manage.py migrate
# создание суперпользователя
# python manage.py createsuperuser
#я создал пользака root пароль 1234
# суперюзера надо зарегать
# перейти в файл admin.py приложения
#там прописать все наши модели, чтобы они закинулись в админку
#установка DRF!!!!!!!!!!!!!!!!!
# pip install djangorestframework
#потом нужно зарегать приложение DRF 
#в файле settings.py в списке INSTALLED_APPS добавить приложение с названием rest_framework
# импортируем ветку generics, в ней много базовых классов для представлений для DRF. Далее в файле views продолжаем


#3. Базовый класс APIView для представлений | Уроки по Django REST Framework!!!!!!!!!!!!!!!!!!!!!
#при создании апи нужны 3 составляющие:
# 1. Создание представления - views
# 2. Создание сериализатора - для валидации данных как я понял
# 3. Маршрутизация - urls.py
# Рассмотрим представления
# есть класс в DRF класс APIView - этот класс стоит во главе иерархии всех классов представления DRF. То есть другие классы представления наследуются от него. Он представляет собой базовый класс представлений в рамках DRF, базовый имеется ввиду самые базовые функции без лишних конструкций. В доукментации есть описания классов которые наследуются от APIView, их можно потом юзать.
# Сначала определим метод get в этом классе. ОН будет отвечать за get запросы, они будут через него автоматом работать. 
#программа которая отправляет какие либо запросы в API - это постман, самая распространенная программа для запросов. Можно отправлять какие-либо get или post запросы. 
#нужно установить postman
#создаем там новую вкладку new_tab
#там можно выбрать запрос get и в урл скопировать нашу ссылку для представления http://127.0.0.1:8000/api/v1/goodlist/
# Вернется наш словарик, который мы там возвращаем в функции get
#если выбрать сейчас post запрос, то выйдет ошибка, метод post не разрешен. 
# {
#     "detail": "Метод \"POST\" не разрешен."
# }
#такой ответ генерирует базовый класс APIView из DRF. Такой ответ был выдан из-за того что не был определен метод post
#чтобы ошибки такой не было, нужно определить метод post, его нужно так и назвать def post
#теперь в постмане будет возвращаться то, что мы возвращаем в нашей функции post
#теперь попробуем сделать запрос в БД. Сделаем запрос товаров из БД. Они все отобразятся в браузере.
# Также так как мы определили метод post, то в браузере автоматом будет форма для добавления товаров, ее сгенерировал DRF автоматом. Без сериализатора она не работает, но отображается. Если нужно можно сделать сериализатор, тогда будет работать. 
#Аналогично будет и postman
# Если отрправить get запрос, то вернутся значения из БД, те же самые что и в браузере
#в Postman есть вкладка pretty, там данные упорядочены в удобном виде разбитые по строкам. Есть еще вкладка Raw, там сырые данные из запроса, просто сплошным текстом. Preview - это примерно то же самое что и Raw. 
#теперь модифицируем post запрос, чтобы он добавлял новые данные в БД. 
#теперь метод пост добавляет новую запись в БД и возвращает то что было добавлено. 
#теперь можно через программу postman отправить post запрос для добавления строки в БД. Как это сделать. Нужно в программе postman с той же самой ссылкой выбрать post запрос, потом перейти на вкладку body, там пишется тело запроса. Там нужно выбрать raw, это сырой запрос. В этой вкладке нужно прописать словарик с нужными данными для добавления строки в БД. 
#данные нужно написать те, которые мы берем из request в функции post нашей вью в виде словаря. Также по умолчанию в postman выбран заголовок запроса HTTP - Text, а нам нужно выбрать JSON. 
# Также немало важно. Если есть поля с вторичным ключом, то в названия нужно дописывать _id, например не просто group, а group_id и функции post и в JSON, иначе будет ошибка при добавлении записи в БД. 
# {
#     "name_product": "Зубная паста",
#     "slug": "tooth_paste",
#     "price": 110,
#     "photo": "photos/2024/01/26/400.jpg",
#     "stock": 11,
#     "group_id": 3
# }
#в случае если будет что-то не так, то возвращается не json в postman, а html ошибка из джанго. Джанго сам ее формирует. В postman эту же html страницу можно посмотреть на вкладке Preview внизу, и в Pretty будет только код html
#у меня почему-то выходила ошибка 'utf-8' codec can't decode byte 0xff in position 0: invalid start byte
#но запись в базу при этом добавлялась. Из-за чего выходит ошибка, непонятно, вроде сделал все верно. 
#в джанго встроенные html страницы для отображения ошибок. 
#когда на сервер приходит HTTP запрос от клиента в наш API, маршрутизатор передает этот запрос фреймворку, и DRF вызывает нужный метод из класса представления для нужного типа запроса get, post, delete и тд. Получется класс APIView связывает запрос с соответствующим методом из класса который мы пропишем. 

#4. Введение в сериализацию. Класс Serializer | Уроки по Django REST Framework!!!!!!!!!!!!!!!!!!!!!
# При обмене данными через API чаще всего используют форматы JSON и XML. JSON чаще. Иногда разрабатывают свой собственный формат для обмена, но редко. 
# Сериализатор - это конвертатор объектов языка python в JSON формат. Это его основная функция. Также он конвертирует модели джанго и наборы queryset. Также и наоборот из JSON в объекты питона. 
#перейдем в файл serializers.py там пропишем класс, который будет преобразовывать в JSON формат, как бы имитировать нашу модель. 

# Как я понял в качестве сериализатора в FastApi используется pydentic. С ним надо тоже разобраться!!!!!!!!!!!!


#5. Методы save(), create() и update() класса Serializer | Уроки по Django REST Framework!!!!!!!!!!!!!!!!
# наш класс сертиализатор только преобразует данные в формат json и обратно. Но сериализаторы должны сохранять и изменять данные в БД и удалять. У нас пока это делает GoodsAPIView с базовым классом APIView
# для этого можно в классе GoodsSerializer переопределить 2 метода create и update
# create(self, validated_data) - для добавления (создания) записи (данных)
# update(self, instance, validated_data) - для изменения данных (записи)


#6. Класс ModelSerializer и представление ListCreateAPIView | Уроки по Django REST Framework!!!!!!!!!!!!!
# ранее у нас был сериализатор связанный с моделью БД. Мы использовали класс Serializer, который связываться с моделью БД. МОжно удалять, добавлить, изменять, получать данные из БД. 
# Для этой схемы есть специальный класс сериализатор serializers.ModelSerializer. Он значительно упрощает работу с сериализатором. С ним не нужно прописывать типы полей вручную в самом классе. В основном там нужен только класс Meta.
#также есть специальные вью классы для упрощения работы. Перейдем во воью создадим класс и наследуем его от ListCreateAPIView. Импортировать их нужно из ветки generics
# Ссылка на документацию с классами представлений:
# https://www.django-rest-framework.org/api-guide/generic-views/

#7. Представления UpdateAPIView и RetrieveUpdateDestroyAPIView | Уроки по Django REST Framework!!!!!!!!!!!!!!!!
# ListCreateAPIView - это для post и get запросов. А UpdateAPIView для изменения в БД, то есть put и putch запросов. В это классе UpdateAPIView есть классы миксины в которых описана логика для видов запроса put и putch. Другие виды запросов там не прописаны и постман будет писать ошибку запрос не разрешен. 
# Но часто в проектах требуется применять все виды запросов CRUD. Для этого есть класс RetrieveUpdateDestroyAPIView, в нем можно делать все виды запросов. В нем есть все нужные миксины, то есть он наследуется от всех нужных миксинов для операций CRUD. Пропишем клас с наследованием от RetrieveUpdateDestroyAPIView. Если сделать класс с этим классом, то в браузере можно будет посмотреть, изменить и удалить и джанго также сразу отобразит фронтовую часть для всех этих действий. Можно изменить, удалить и посмотреть. Если удалить и потом через постман посмотреть, то постман напишет страница не найдена. 
#Также весь фронтенд который идет из джанго можно отключить, чтобы потом в других приложениях при апи запросах не тянулся фронт из джанго, а только нужные данные. 
# Чтобы фронт из джанго отключился нужно в файле settings.py прописать следующее:
# REST_FRAMEWORK = {
# 	'DEFAULT_RENDERER_CLASSES': [
# 	'rest_framework.renderers.JSONRenderer',
# 	#'rest_framework.renderers.BrowsableAPIRenderer', #эту строку можно закоментировать, она отвечает за отрисовку рест страниц при апи запросах. Без нее будут просто json возвращаться. Пока пилим проект ее можно оставить, но потом закоментировать. 
# 	]
# }

# также есть и много других настроек, их можно гуглить. 

#8. Viewsets и ModelViewSet | Уроки по Django REST Framework!!!!!!!!!!!!!!!!!!!!!!!!
#Мы сделали несколько классов вью с однотипным кодом. В DRF их можно объединять, есть специальный функционал Viewsets. Ссылка на док-цию: https://www.django-rest-framework.org/api-guide/viewsets/
# Мы воспользуемся классом ModelViewSet, он поддерживает работу с моделями. Прописал этот класс во вьюшках. Он по сути заменяет все те предыдущие классы. 

#внутри те же самые параметры. Перейдем теперь в urls.py, там теперь в урл можно писать еще и параметры с видами запросов и названиями методов для их обработки, все это прописывается в виде словарей, ключ это название запроса, значение это название метода. Прочитать про название методов для запросов можно в док-ции. И также все виды запросов работают через браузер или постман.

#Мы в urls.py пишем 2 урл для пост и гет запроса, урл для гет без параметра, а урл для пост put delete с параметром.
# Но также в джанго чтобы на писать по 2 строки УРЛ с одинаковымы адресами для пост и гет запроса, есть специальный функционал для роутеров. Есть SimpleRouter и DefaultRouter. Импортировать их и прописывать нужно в urls.py, импорт такой: from rest_framework import routers. Потом нужно создать объект роутера. Потом нужно в этом объекте зарегать объект вьюсета. 
# router = routers.SimpleRouter()#SimpleRouter это класс роутера
# router.register(r'good', GoodsViewSet)#GoodsViewSet - это клас вьюсета. 
#теперь его нужно прописать в маршрутах. Там мы прописываем весь набор маршрутов, который был сгенерирован роутером. 
# path('api/v1/', include(router.urls))#так прописали путь
#теперь в браузере если перейти по ссылке http://127.0.0.1:8000/api/v1/good/, то отобразится наши данные из БД и можно сделать гет и пост запрос, то есть посмотреть и добавить данные. Также если прописать параметр в маршруте http://127.0.0.1:8000/api/v1/good/11, то то можно будет делать delete и put запросы. 
#То есть тут будет присутствовать весь функционал для работы с БД CRUD. То есть 1 класс и 2 строки кода в нем дает все это, но и роутер зарегать надо. 
#Также можно и юзать другие урезанные классы, в случае если нам не нужен лишний функционал. Например класс ReadOnlyModelViewSet позволяет тольк читать инфу, то есть только гет запрос. Параметр тоже можно добавлять, но доступен также только просмотр. 
#Там внутри таких классов подключены нужные миксины с нужными видами запросов. То есть по факту мы можем точно также юзать нужные нам миксины из базовых классов DRF. Будет все то же самое. 

#9. Роутеры: SimpleRouter и DefaultRouter | Уроки по Django REST Framework!!!!!!!!!!!!!!!!!!!!!
# Ссылка на док-цию про использование роутеров: https://www.django-rest-framework.org/api-guide/routers/
#так выглядит список урл default: 
# [<URLPattern '^good/$' [name='goods-list']>,
#  <URLPattern '^good\.(?P<format>[a-z0-9]+)/?$' [name='goods-list']>,
#  <URLPattern '^good/(?P<pk>[^/.]+)/$' [name='goods-detail']>, 
# <URLPattern '^good/(?P<pk>[^/.]+)\.(?P<format>[a-z0-9]+)/?$' [name='goods-detail']>, 
# <URLPattern '^$' [name='api-root']>, 
# <URLPattern '^\.(?P<format>[a-z0-9]+)/?$' [name='api-root']>]
#в нем есть 3 группы маршрутов. 
# Первые 2 строки выше отвечают за получение списка позиций, то есть когда запрос идет без параметра в УРЛ, также есть и все операции CRUD, если они прописаны в классе представления
# 3 и 4 строки отвечают за получение какой одной строки, то есть когда запрос идет с параметров для фильтрации, аналогично есть нужные операции CRUD если они прописаны
# 5 и 6 строки они присутствуют только в default router, эти маршруты присутствуют только в самом роутере. То есть маршрут без префикса из роутера.  
#если перейти по маршрут из default то есть по 5 или 6 строке, то там будет словарь (возможно json) по ссылкой на маршрут из 1 и 2 пункта, то есть ссылка на обычнный маршрут без параметров. 
# {
#     "good": "http://127.0.0.1:8000/api/v1/good/"
# }
#если юзать SimpleRouter то default маршрута (http://127.0.0.1:8000/api/v1/) не будет, и если по нему перейти, будет отображаться НОС. 
# Также в списке выше есть поле [name='goods-list'], тут прописывается имя маршрута. Это имя можно юзать на фронте в html например как понял в jinja. Имена там формируются автоматом. 
# Эти имена формируются из названия модели с маленькой буквы потом "-" потом слово "list" в случае если это список или слово "detail" в случае если есть параметр в урл для фильтрации. Префикс в роутере не влияет на имя маршрута, только на путь самого маршрута. Но имя можно указать самим прописать еще один параметр basename="имя урл".
#  Например так: basename="tovar"
# теперь имена урл будут выглядеть так: [name='tovar-list']
#причем этот параметр basename обязателен если не указывать во вью классе атрибут queryset. Если не указать ни queryset ни basename то роутер не сможет подставить имя модели при формировании имен маршрута. 

# Предположим если стандартных маршуртов не достаточно и нужно определить свой. Для этого есть специальный декоратор @action() для определения новых маршрутов. Новые маршруты можно прописать в классе вью в отдельных УРЛ. Например выведем список групп, а не список товаров. Перейдем в файл views.py приложения. 

# ост 9 мин













































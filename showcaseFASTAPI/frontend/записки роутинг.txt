уроки:
https://www.youtube.com/watch?v=wZ1P3QM9_p8&list=PLiZoB8JBsdznY1XwBcBhHL9L7S_shPGVE&index=4


поставим библиотеку react-router-dom
npm install react-router-dom

далее в базовом файле main.jsx нужно обернуть наше приложение в тег BrowserRouter
также его нужно импортировать из react-router-dom

импортируем в App.jsx из Routes, Route, Link из react-router-dom
Routes - роуты
Route - роут
Link - ссылка!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
ранее был компонент switch
сейчас его нет, вместо него Routes
создадим папку pages
в ней создадим файлы для страниц
и импортируем их в App.jsx
import Homepage from './pages/Homepage'
import Aboutpage from './pages/Aboutpage'
import Blogpage from './pages/Blogpage'
import Notfoundpage from './pages/Notfoundpage'

для роутинга сделаем тег Routes
и дочерними элементами в нем будут компоненты Route
один из дочерних элементов
<Route path="/" element={<Homepage />} />
<Route path="/about" element={<Aboutpage />} />
<Route path="/blog" element={<Blogpage />} />
<Route path="*" element={<Notfoundpage />} />
писать нужно именно так, а не с закрывающим и открывающим тегом

создадим компоненты
сделаем компонент Layout, туда перенесем ссылки Link

и создадим там компонент Outlet !!!!!!!!!!!!!!!!!!!!!!!!!!!!
суть его такая, что мы говорим нашей разметки куда мы хотим вставить все остальное
то что идет после Outlet это то куда мы хотим вставить весь остальной контент
у нас пока только футер, но там будет и все остальное
создаем новый Route в файле App.jsx
В нем будут все наши Route со ссылками
то есть получается тут будет общая обертка, и в ней будут вложенные роуты, их можно динамически менять
причем этот компонент будет предоставлять место куда будет отрисовываться все дочернее содержимое. То есть там где мы написали Outlet и ниже
То есть, мы в файле Layout.jsx написали сначала тег header, потом Outlet, а потом footer, и Outlet это содержимое нашего роута, то есть как было тело между хедером и футером. Вроде понятно
пропишем такую структуру
<Route path="/" element={<Layout />}>
	<Route index element={<Homepage />} />        
	<Route path="posts" element={<Blogpage />} />
	<Route path="about" element={<Aboutpage />} />
	<Route path="*" element={<Notfoundpage />} />
</Route>
тут получается будет Homepage идти в корне по адресу "/", далее добавляться будут ссылки posts about и др
Outlet - это как бы блок в jinja
в него можно всталять блоки кода

Компонент NavLink и его кастомизация в React-Router 6!!!!!!!!!!!!!!!!!!!!!!!!!
это выделенные ссылки
сделаем стиль для выделения ссылки
и сделаем переменную в которой будет переключаться стиль
const setActive = ({isActive}) => isActive ? 'active-link' : '';
и потом в наших линках стиль будем указывать
className={setActive}
по умолчанию в теге уже указан className стиль active, если мы создаим свой то его надо будет прописать как  className
также можно и прописать style
он принимает объект, но можно передать и функцию. 
в NavLink есть встроенный параметр isActive
его можно проверять

сделаем кастомный линк

import { Link, useMatch } from 'react-router-dom'

export default function CustomLink({ children, to, ...props }) {
	const match = useMatch(to);
	console.log({match})


	return (
		
		<Link 
			to={to}
			style={{
				color:match ? 'var(--color-active)' : 'white',
			}}
			{...props}>

			{children}
		</Link>
		)
}

не разобрался как работает useMatch, и кажется что className достаточно будет



Параметры в ссылках в React Router 6!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
параметр пишется примерно так
<Route path="posts/:id" element={<Singlepage />} />
:id это параметр роутера
создадим файл Singlepage.jsx в папке pages
в нем сделаем простой компонент Singlepage
import React from 'react';


export default function Singlepage() {

	return (
		<>
			<p>1</p>

		</>
		)
}

будем использовать хук useParams для использования параметров
можно в ссылке использовать и несколько параметров
и потом в логике приложения параметры можно использовать
то есть в ссылку что-то передали и потом используем как в питоне
обычно используется один параметр, а не 2. Я так и делал в питоне
при использовании useParams() выводятся сразу весь список параметров если их несколько
useParams() - это типа словарь в питоне
можно обращаться useParams().название параметра и выведется значение параметра
либо можно обращаться и так: const {id} = useParams();
и у нас будет переменная с названием id
ее можно применять в коде jsx
в компоненте Blogpage сделаем апи запрос, и там будем выводить id от поста в через компонент Singlepage, он будет автоматом подтягивать ссылку
в файле Singlepage сделали так, чтобы при запросе линка из компонента Blogpage к сайту выводился сам пост
юзнули состояние state и useEffect

при добавлении зависимости в useEffect запрос делается каждый раз

сделаем отдельный роут на котором будем создавать новые страницы
создание страниц!!!!!!!!!!!!!!!!!

сделаем компонент:

export default function Createpost() {
	return (
		<div>
			<h1>Create a post</h1>
		</div>
		)
}


и вызовем его в роуте
<Route path="posts/new" element={<Createpost />} />

получается у нас теперь будет отдельный роут с нужной нам страницей

и можно сделать и любую другую страницу, например редактирования
для редактирования уже нужен параметр
используем useParams
то есть просто выведем нужный нам id от какого либо поста
причем параметр не обязательно должен быть в конце урл, можно его юзать и в середине, функционал не изменится. НО по хорошему нужно юзать какую либо проверку на типы данных, сейчас никаких проверок нет у нас пока. 



Работа с историей, локацией и приватными роутами в React-router 6!!!!!!!!!!!!!!!!!!!!!!!
сделаем кнопку назад. Она должна взаимодействовать с историей браузер, и переходить на страницу назад. 
идем в файл Singlepage.jsx
импортируем хук useNavigate
создадим константу
const navigate = useNavigate();
и ее можно использовать в стрелочной функции
const goBack = () => navigate(-1);
эта функция принимает один параметр ссылку либо цифру. То есть написать ссылку в виде строки (например "/post"), то мы перейдем на ту ссылку, которую мы напишем. Если написать цифру, то будет переход на страницу назад или вперед.
если написать -1, то это как нажать в браузере один раз кнопку назад. Если написать положительную цифру, то будет шаг вперед.

пример ссылки переадресации:
const goHome = () => navigate('/', {replace: true});

{replace: true} означает что мы не идем по истории, а просто редирект делаем.
также можно передать какой либо state и далее через двоеточие контекст, как в питоне передаем, тут также
const goHome = () => navigate('/', {replace: true, state: контекст});
мы сделали переход через navigate на страницу Home, но так лучше не делать. ЛУчше использовать Link, то есть переход по ссылке. То есть на кнопке лучше юзать Link, а если это будет автоматическая переадресация, то так можно делать. 

обычная переадресация!!!!!!!!!!!!
то есть при переходе по какой либо ссылке будет автоматическая переадресация на другую ссылку
для этого используем компонент Navigate, его импортируем вместе с Route из 'react-router-dom'
и пропишем еще один роут:
<Route path="about-us" element={<Navigate to="/about" replace />} />
и передаем булевое значение replace, и тогда в истории браузера не будет сохраняться этот переход по ссылке
при переходе по ссылке /about-us автоматом перейдем на ссылку /about

объект location!!!!!!!!!!!!
виндоус location лучше не юзать, а нужно юзать хук useLocation
импортируем его из 'react-router-dom'
и выведем в консоль useLocation
там будет такой словарик:

hash: ""
key: "ri5db4cr" это уникальный ключ этой страницы
pathname: "/posts" полный путь страницы его можно юзать в других запросах
search: "" это какие либо доп параметры, например id
state: null это контекст как в питоне любая инфа которую можно передать

для примера сделал такой navigate:
const goTest = () => navigate("/posts", {state: 123});
и его закинул в кнопку, етперь при переходе по этой ссылке, будет прокидываться state со значением 123
обычно делают по другому. 

location поможет работать в приватными роутами
это может быть полезно при авторизации и регистрации
видео по авторизации в react: https://www.youtube.com/watch?v=ivtbRBEjLW8
нам важно как это работает с роутингом
создадим папку hoc, там будут компоненты высшего порядка с защитой, например роуты с авторизацией

это видео: https://www.youtube.com/watch?v=jv0ckzkKYzU&list=PLiZoB8JBsdznY1XwBcBhHL9L7S_shPGVE&index=5
ост 10:40
Продолжение приватность!!!!!!!!!!!!!!!!!!!!!!!!!!
создал файл RequireAuth, и в нем компонент RequireAuth
перейдм в него
в этом компоненте будет параметр children, в роли children будут выступать любая страница. То есть страница, которая будет скрываться авторизацией. То есть не видна без авторизации, она будет дочерней у компонента авторизации
если авторизация тру, то отрисовываем страницу дочку, либо не отрисовываем

if (!auth) {//если тру то возвращаем компонент Navigate. Если фолз, то что то другое. То что будет возвращать данный компонент RequireAuth
		return <Navigate to='/login' state={{from: location}} />
	}
без авторизации можно возвращать брать инфу из state со значением location, как это делать пока не понятно
создадим файл для страницы авторизации Loginpage.jsx

напишем там функцию:

const Loginpage = () => {
	const navigate = useNavigate()
	const location = useLocation()

	const fromPage = location.state?.from?.pathname || '/'

	return (
		<div>
			<h1>Login page</h1>
			{fromPage}
		</div>
		
		)
}
тут юзаем location, и берем из нее путь
добавим роут в файл Router с логином
и импортируем RequireAuth. И обернем компонент Createpost в наш компонент RequireAuth
это для проверки авторизованы мы или нет
такой роут получился
<Route path="posts/new" element={
            <RequireAuth>    
                <Createpost />
            </RequireAuth>
        } action={createPostAction} />
при такой реализации, когда пользак перейдет по ссылке posts/new произойдет редирект на RequireAuth в случае если пользак не авторизован и параметр auth из RequireAuth равен фолз. И RequireAuth делает перекидывает на роут Loginpage с путем /login, который соответсвует компоненту Loginpage.
Если пользак уже был авторизован, то мы попадем на children, а children это Createpost.
Есть несколько способов авторизации. Через Redux, через React context
Создадим файл AuthProvider.jsx в папке hoc
обернем все наши роуты в компонент AuthProvider. 
Точнее не роуты, которые в файле Router.jsx, а в файле App.jsx компонент <RouterProvider router={Router} /> нужно обернуть в тег <AuthProvider>. Также <AuthProvider> нужно импортировать в App.jsx

Это означает что мы можем какую то инфу достать из AuthProvider.
функция AuthProvider

export const AuthProvider = ({children}) => {
	const [user, setUser] = useState(null);
	const signin = (newUser, cb) => {
		setUser(newUser);
		cb();
	}
	const signout = (cb) => {
		setUser(null);
		cb();
	}

	const value = {user, signin, signout}


	return <AuthContext.Provider value={value}>
		{children}
	</AuthContext.Provider>

}

так как мы в этой функции прописали <AuthContext.Provider value={value}>
то теперь из любого роута можно получить значение контекста value через хук useContext. 
и создадим кастомный хук useAuth
в нем пропишем функцию: 

import { useContext } from 'react'
import { AuthContext } from '..hoc/AuthProvider'

export function useAuth() {
	return useContext(AuthContext)
}

он будет подтягивать контекст AuthContext из AuthProvider
его будем вызывать при обращении к конектстуconst value = {user, signin, signout} для удобства сделали так
и переделаем RequireAuth, чтобы подтягивался юзер, если его нет, то будет фолз и переадресация
берем объект const {signin} = useAuth()
через наш хук. И потом его используем. 

теперь сделаем выход из учетки - разлогинивание



<AuthProvider>









Отправка данных через роутинг React router 6.4!!!!!!!!!!!!!!!!!!!!!!!!!!!
тут инфа по формам чепрез роутинг
форма не будет приводить к перезагрузке страницы
запросы будут асинхронными
на данный момент в файле Createpost.jsx ничего нет
создадим файл NewPost.jsx в компонентах
Импортируем компонент Form из 'react-router-dom'
роутинг предлагает возможности связанные с формой
и создадим функцию для формы
компонент Form под капотом имеет функционал который отправляет форму без перезагрузки страницы
в форме нужно написать определенный свойство action который будет отвечать за отправку данных куда то
action нужно передать определенному роуту Route в файле App.jsx

пока делаю без авторизации...

в action нужно указать путь к нужной нам ссылке роута posts/new
функция формы будет выглядеть так:

export default function NewPost() {
	
	return (
		
		<>
			<Form action="posts/new" method='post'>

				<label>
					Title:
					<input type="text" name="title" />
				</label>
				
				<label>
					Body:
					<input type="text" name="Body" />
				</label>

				<input type="hidden" name="userId" value="1" />

				<input type="submit" value="Add post" />

			</Form>
		</>


		)
}

далее перейдем в файл Createpost
и туда добавим компонент NewPost
и также нужно добавить функцию экшена action который будет определенную логику создавать
добавим в файле Createpost вне функции компонента Createpost еще одну асинхронную функцию createPostAction
с параметром request, он обязателен
и экспортируем ее
и импортируем в App.jsx
в Router.jsx роут "posts/new" пропишем так:

<Route path="posts/new" element={
            <Createpost />
          } action={createPostAction} />

то есть добавили action={createPostAction} после element 
далее в функции createPostAction создал переменную:
const formData = await request.formData();
request.formData() это объект данных из формы
напрямую к нему доступа нет, только так. Есть методы get например и другие
потом создадим еще одну функцию
это будет пост запрос на сервер, назовем createPostRequest

async function createPostRequest ({title, body, userId}) {
	const res = await fetch('https://jsonplaceholder.typicode.com/posts', {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ title, body, userId })
		})
		
	const newPost = await res.json()

	return newPost
}

отправляем на ссылку 'https://jsonplaceholder.typicode.com/posts' пост запрос с данными из {title, body, userId}

JSON.stringify({ title, body, userId }) это создание JSON запроса, то есть мы берем данные из формы, и кидаем их на сервер
и возвращаем json, потом будем юзать еще

далее в функции createPostAction создадим переменную:
post = createPostRequest()
присваиваем вызов функции выше
и создадим объект с данными из формы
const newPostObj = {
		title: formData.get('title'),
		body: formData.get('body'),
		userId: formData.get('userId'),
	}

в скобках get мы указываем названия полей name из формы
потом этот объект нужно передать в функцию нашу
post = createPostRequest(newPostObj)

на вкладке network в разделе Ftch/XHR моэжнго посмотреть инфу по нашему запросу
на вкладке payload инфа которую мы передали
на вкладке preview инфа которую мы получили от сервера
так как бэк фейковый, поэтому у нас ничего не добавится
но можно все увидеть на вкладке network


далее делаем редирект с помощью спец функции redirect()
в скобках пишет ссылку на какой роут нужен редирект

еще можно показать пользаку что идет загрузка
или заблочить кнопку чтобы он не нажал второй раз
в файле NewPost.jsx в кнопке допишем параметр disabled={submitting}
и параметр в функции добавим submitting. этот параметр будет означать, тру или фолз, то есть кнопка будет блочиться когда на нее жмем, и через некоторое время разблокируется
чтобы это значение приходило идем в файл Createpost.jsx

используем хук useNavigation. У этого хука есть несколько состояний. Состояние со значеним submitting это как бы загрузка
создадим объект
const navigation = useNavigation()
и допишем параметр в компоненте NewPost
submitting={navigation.state === 'submitting'}
в этом случае, если состояние будет равно submitting, то заблокируем кнопку. Это состояние потом меняется когда загрузка проходит, и кнопка разблокируется
------------------------------------------------------------------
Описание работы формы!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
по итогу, мы отправляем форму на определенную ссылку. В роутинге, то есть у нас это файл Router.jsx, должен быть роут по этому же пути как в форме, и компонент формы его записываем в свойство element у нас это Createpost, и в нем (Createpost) должен отрабатывать компонент (NewPost), который у нас рисует форму. Еще, помимо element, у этого роута должно быть свойство action, и ему должна быть присвоена асинк функция, которая отправляет данные на сервак, у нас это функция createPostAction из файла Createpost.jsx
Функция createPostAction получает данные формы через параметр request, и отправляет данные через fetch запрос данные на сервак. Для отправки фетч запроса делали отдельную функцию createPostRequest. Она берет данные объекта или по отдельности, главное чтобы были все данные, и отправляет на сервак. 
В итоге функция createPostAction делает переадресацию на другой адрес с помощью функции redirect, ее импоритуем из react-router-dom. Но можно и не делать переадресацию. Далее будет пример с редактированием без переадресации
------------------------------------------------------------------
асинхронная функция - компонент, которая будет добавлять значения из формы по функции которую мы передаем в свойство action. Эта функция взаимодействует с БД и делает переадресацию. Она делается не всегда, по случаю

создание разобрали

теперь идем к редактированию!!!!!!!!!!!!!!!
Editpost.jsx тут будет использовать функцию компонент для формы
сама форма в файле 
UpdatePost.jsx
создадим там функцию для формы
и импортируем также тег Form
пропишем там значение через проп defaultValue, при его использовании значение можно редактировать, с пропом value значения нельзя редачить
и в defaultValue передаем значения из редактируемого объекта
и еще берем id 
<input type="hidden" name="id" value={id} />
он тоже нужен, так как это id объекта
его указываем скрытым
из параметров прокидываем везде value в скрытых полях, типа id и userId
в других параметрах прописываем значения через defaultValue. 
теперь нужно понять как получать данные
идем в файл Editpost.jsx
как вариант
можно было передавать state через функцию Singlepage, где мы перебираем все посты, и передавать также и там объект, как контекст в питоне.
но это работает, только если переадресация будет на другую страницу, а не на эту же, так как state уже не будет
но в момент переадресации state уже не будет
используем loader который делали ранее для предзагрузки данных. Можно сделать и отдельный лоадер, но пока используем тот же самый, он тоже подойдет. Лоадер это функция для предзагрузки данных. 

<Route path="posts/:id/edit" element={<Editpost />} loader={postLoader} />

Получать данные будем через хук useLoaderData
его переиспользуем по аналогии как в Singlepage

у хука useNavigation есть несколько состояний. Одно из них submitting, и мы проверяем, если такое состояние есть, то мы делаем кнопку неактивной

//эта функция отправляет данные на сервер
const updatePost = async (post) => {
	const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${post.get('id')}`, {
		method: 'PUT',
		body: post
	})
}

параметр post в него передаем объект из formData
почему то id не указали, посмотрим что дальше
в нашем случае мы просто передаем объект
и не передаем body: JSON.stringify({ title, body, userId })
и это headers: { 'Content-Type': 'application/json' },
тут само все норм будет
body: JSON.stringify({ title, body, userId }) это можно и передать, но пока и так норм сработает, так можно, мы передали просто post, это объект из формы будет. В этот параметр будет передаваться formData
formData сама по себе распарсится
//эта функция отправляет измененные данные на сервер
const updatePost = async (post) => {
	const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${post.get('id')}`, {
		method: 'PUT',
		body: post
	})
}

в updatePostAction мы вызываем updatePost, и передаем в нее formData.
в updatePostAction возвращаем какой-то message
то есть мы изменили пост, и получим сообщение. И отобразим его на странице

также для получения сообщения есть хук useActionData()
его импортируем из react-router-dom


в методе Editpost создадим константу const data = useActionData()
он возвращает объект, который мы создадим. Этот хук берет текст из action который он возвращает. 
Далее выведем ее сообщение в data в jsx

{data?.message && <div style={{color: 'blue'}}>{data.message}</div>}

тут если не пусто в сообщении, то оно выведется
в нашем случае мы не редиректимся. Тут по случаю. То есть как бы кнопка сохранить, мы зашли, измененения внесли, и сохранили. Далее можем переходить на другие ссылки. 

также можно прикрутить валидацию, пока не сложную
if (!formData.get("title") || !formData.get("body")) {
		return {message: 'Все поля обязательны!'}
	}

сделать лоадер. У меня он не работает. Пройти урок по лоадеру
































Предзагрузка данных через роутинг!!!!!!!!!!!!!!!!!!!!!!!!!

есть возможность загружать данные в момент перехода на ссылку. То есть не через useEffect, который в конце все грузит, а сразу при переходе по ссылке
через роутинг

BrowserRouter это некий провайдер который обеспечивает роутинг. Но это устаревший провайдер.
в блоге Blogpage у нас данные грузятся в useEffect, потом пападают в состояние posts
Singlepage тут тоже через useEffect грузится все
BrowserRouter актуален если мы не будем загружать данные в момент перехода на страницу
уберем BrowserRouter из main.jsx
оставим только это:
createRoot(document.getElementById('root')).render(
  <StrictMode>
  
    <App />
  
    </StrictMode>
)
потом идем в файл App.jsx
для этого в файле App.jsx импортируем туда RouterProvider
import { RouterProvider } from "react-router-dom"
далее можно создать константу Router

const Router = createBrowserRouter(createRoutesFromElements(
    <Route path="/" element={<Layout />}>
        <Route index element={<Homepage />} />
        <Route path="posts" element={<Blogpage />} />
        <Route path="posts/:id" element={<Singlepage />} />

        <Route path="posts/:id/edit" element={<Editpost />} loader={postLoader} action={updatePostAction} />
        <Route path="about" element={<Aboutpage />} />
        <Route path="about-us" element={<Navigate to="/about" replace />} />
        <Route path="*" element={<Notfoundpage />} />

    
        <Route path="posts/new" element={
            <Createpost />
        } action={createPostAction} />
    </Route>
))

также нужно импортировать createBrowserRouter и createRoutesFromElements
import { Route, Navigate, createBrowserRouter, createRoutesFromElements } from "react-router-dom";

отличие в том, что нет сущности которая называется Routes. Этот тег убираем.
и все что внутри Routes оставляем
и далее в функции App пишем компонент RouterProvider:
<RouterProvider router={Router} />
у этого компонента есть параметр router в него записывает наш объект константу Router
также константу можно и отдельным файлом вынести, но можно и в файле App оставить

теперь идем в файл Blogpage
у нас задача получать сущности через роутинг, а не useEffect, то есть запросы делать через роутинг
чтобы получать такие сущности, нужно создавать доп функции - лоадеры
const loader
идем в файл Blogpage.jsx
создадим функцию blogLoader
обычно также такие функции хранят рядом с компонентом, чтобы было понятно что к чему относится
в функции blogLoader всегда есть 2 параметра {request, params}
параметры функции это params, а request это запрос
внутри этой функции должно быть примерно тоже самое что и в useEffect. Но теперь нам не нужен state
и данные эти можно достать через хук useLoaderData
и просто запишем их в переменную const posts = useLoaderData()
теперь без useState useEffect теперь все работает также

если {request, params} не используется, то их можно не писать в параметрах. У нас там только fetch, поэтому можно и без них

Идем в файл Singlepage
там параметр {params} нужен будет
там мы получали параметр id через useParams
теперь будем получать его подругому
state тоже убираем, и useEffect
и переносить часть fetch в нашу функцию
через useLoaderData грузим наш объект
но нужен id
в функции postLoader пропишем получение id и объекта поста

const postLoader = async ({params}) => {
	const id = params.id
	const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`)
			
	const post = await res.json()
	return {post, id}
}

и через useLoaderData так присвоим значения
const {post, id} = useLoaderData()
часть с проверками можно и убрать теперь в jsx при возврате

в файл Router.jsx, импортировал функцию нашу и прописал ее в параметре loader наших компонентов. 

Теперь нужно сделать предзагрузчик, чтобы при загрузке страници что-то отображалось
идем в файл Blogpage
импортируем defer из react-router-dom
в функции blogLoader
уберем наш код и вынесем его отдельной функцией
и в этой функции будем возвращать это:
defer({
		posts: getPosts()
	})
с функцией defer есть возможность ожидать когда какая-то часть данных будет получена. 
useLoaderData теперь присваиваем в объект posts
const {posts} = useLoaderData()

так как данных еще нет, нужно использовать компонент Suspense, его импортируем из react
и его пропишем при возврате в jsx в компоненте Blogpage
внутри Suspense пропишем компонент Await, его импортируем из react-router-dom
теперь в теге Suspense пишем fallback, там напишем просто заголовок loading
далее в Await нужно написать что именно мы ждем
напишем что мы ждем загрузки постов:
<Await resolve={posts}>
и пока не загрузятся посты будет показан fallback={<h2>Loading...</h2>}
а когда загрузятся будет другое
например полученные посты
и перенесем посты где мы их рисовали в тег Await
и пропишем их в виде стрелочной функции
{
						(resolvedPosts) => (
							<>
								{
								resolvedPosts.map(post => (
									<Link key={post.id} to={`/posts/${post.id}`}>{/*это переход по ссылке Singlepage и он отрисовывает наш id*/}
										<li>{post.title}</li>{/*тут просто список постов*/}
									</Link>
								))
								}

							</>)
					}

это все работает из-за хелпера defer, без него Suspense не может рисовать
погуглил, оказывается все работает без defer, его удалили в 7 версии реакт
Можно теперь просто возвращать объект не оборачивая его в defer, это в функции blogLoader в файле Blogpage.jsx

второй вариант. 
его сделаем в Singlepage
сделаем функцию
async function getPostById(id) {
	const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`)
			
	return res.json()
}
для получения постов через запрос
и переделаем лоадер
const postLoader = async ({params}) => {
	const id = params.id
	
	return {post: getPostById(id), id}
}

далее создадим отдельный компонент

const Post = () => {
	const post = useAsyncValue()
	return (
		<>
			<h1>{post.title}</h1>
			<p>{post.body}</p>
		</>
		)
}

и пропишем Suspense
<Suspense fallback={<h2>Post is Loading...</h2>}>
						<Await resolve={post}>
							<Post />							
						</Await>
					</Suspense>

В нем вызываем наш компонент Post из функции выше

также можно и без defer, он позволяет разделяеть получение данных, например сначала одно, потом другое.
но его удалили из 7 реакта...

можно без него просто разделим 2 разные загрузки
редачим функцию postLoader

const postLoader = async ({params}) => {
	const id = params.id
	
	return {post: getPostById(id), id, comments: getCommentsByPost(id)}
}

и предположим что-то нужно сразу - post, что-то потом - comments
допишем await перед вызовом постов

const postLoader = async ({params}) => {
	const id = params.id
	
	return {post: await getPostById(id), id, comments: getCommentsByPost(id)}
}

это будет означать, что сначала посты, а комменты потом
напишем компонент для комментов

const Comments = () => {
	const comments = useAsyncValue()

	return (
		<div>
			<h2>Comments</h2>
			{comments.map( (comment) => (
				<>
					<h3>{comment.email}</h3>
					<h4>{comment.name}</h4>
					<p>{comment.body}</p>
				</>
				)
			)}
		</div>
		)
}



Вложенный роутинг в React Router 6!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Layout это постоянная составляющая она всегда отображается на странице, это шапка подвал и что=то еще на наше усмотрение
также возможно будут группы товаров или еще что-то что может иметь вложение
в компнненте который имеет вложенность есть символ /, а во вложенных сначала нет слеша
раньше делали вложенные роуты на самих страницах
идем в файл Aboutpage
там можно разместить ссылки о нас и т.д.
компонент 

по пути /about отвечает этот роут в файле Router.jsx
и чтобы можно было сделать вложение, то есть продолжение после about/ в компоненте Aboutpage, нужно в роуете также прописать изменения так:
<Route path="about/*" element={<Aboutpage />} />

и так как мы уже в about/*, значок * означает что возможно продолжение пути path, и поэтому нужно прописать ссылку так:

<Routes>
	<Route path='contacts' element={<p>Our contacts</p>} />
</Routes>

также можно и другие вложенные роуты делать, например
<Route path='team' element={<p>Our team</p>} />
они будут дорисовывать что-то после основного контента страницы

<>
		<h1>Aboutpage</h1>
		<p>ВАся</p>
		<Routes>
			<Route path='contacts' element={<p>Our contacts</p>} />
			<Route path='team' element={<p>Our team</p>} />
		</Routes>
		</>
		)

тут это:
<h1>Aboutpage</h1>
		<p>ВАся</p>
это основной контент, а далее в зависимости от нажатой ссылки.

Ссылки можно прописать и так
<ul>
	<li><Link to="contacts">Our contacts</Link</li>
	<li><Link to="team">Our contacts</Link</li>
</ul>
они будут добавлять текст со значеним в папрамтре to к ссылке и переходить по ней. Не обязательно писать полную ссылку, типа: /about/contacts
у меня не работает. Только переход по абсолютной ссылке

это старый подход. Можно сделать также как с Layout. 
напишем вложенные роуты в файле с роутингом Router.jsx

<Route path="about/*" element={<Aboutpage />}>
	<Route path='contacts' element={<p>Our contacts</p>} />
	<Route path='team' element={<p>Our team</p>} />
</Route>

и чтобы это работало нужно указать компонент Outlet, он будет означать в какое место нам нужно писать наши компоненты из роутов. Outlet импортировать из react-router-dom
перепишем компонент CustomLink
в хук useMatch пропишем объект
const match = useMatch({
		path: to,
		end: to.length === 1,

	});
useMatch может принимать 3 вещи
мы опишем только 2
path: to
означает что путь будет браться из to 
и end это булевый параметр, предполагает полностью включена ссылка или нет
если фолз, это будет значить что главная страница с пустым путем всегда активна
нужно сделать так, что если путь пустой, то мы берем полный путь, если не главная то не полный
пишем еще родин параметр:
end: to.length === 1,
тут какая муть, не совсем понятно, но вроде и так работает. Стили не работают



ErrorElement для обработки ошибок в React приложении!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

есть еще Error Boundary это такой компонент, который отлавливает ошибки. Видео также есть. Но там без роутинга. 

Но сейчас рассмастиваем компонент ErrorElement. Тут ошибки отлавливаем при роутинге. Ошибки будем ловить в момент когда делаем предзагрузку данных используется средства роутинга - лоадеры и тд

ErrorElement - это параметр, который можно передавать в роут Route, чтобы отлавливать ошибки
можно обрабатывать ошибки при лоадерах
этот функцинал доступен только при использовании утилиты createBrowserRouter!!!!!!!!!!!!
в старом BrowserRouter это не работает!!!!!!!!!!!!!
идем в файл Router.jsx
мы можем сделать отдельную функцию, которая будет выводиться когда будет появляться ошибка. 

пропишем в роутере с элементом Blogpage это
errorElement={<h1>Error!!!!!!!!!</h1>}
тогда если у нас выйдет какая-то ошибка то отобразится заголовок h1, который мы прописали. Иногда конечно может и просто пустая страница грузиться. Но все же тоже ловятся ошибки, так как они касаются роутинга. Такие ошибки также ловят Error Boundary

также можно выбрасывать свои ошибки, либо в асинк функции, либо в лоадере
идем в файл Blogpage.jsx
напишем там там условие
if (!res.ok) {
	throw new Response('', {status: res.status, statusText: 'Not Found'})
	 }

!res.ok это проверка что ответ который получили от сервера плохой. ok пришел со значеним false
throw new Response('тут текстовое сообщение которое попадает в body', {status: res.status, statusText: 'Not Found'})
далее тут указан статус и текст статуса, статус берем из результата

обычно заголовки в errorElement не пишут. 
создадим ErrorPage.jsx в папке pages
это компонент для ошибки
так как мы выше выбросили инфу кодом throw new Response, то инфу из него нужно получить
для этого используем хук useRouteError, его импортируем из react-router-dom
и создадим константу и в нее запишем вызов функции useRouteError, это будет объект ошибки
и так как мы выбрасываем Response, то у него будут методы json, text и тд и status statusText
в ErrorPage пропишем получение статуса и выброс ошибки
<h1>{error.status}</h1>
{/*<h2>{error.statusText || 'ТУТ ОШИБКА!'}</h2>*/}
и передадим наш компонент в параметр errorElement
errorElement={<ErrorPage />}
теперь мы на странице получаем, то что указали при выбросе:
throw new Response('', {status: res.status, statusText: 'Not Found'})
то есть в функции getPosts файла Blogpage.jsx мы проверяли условие, если там что то не так со статусом, то выбрасывали ошибку и отлавливали ее с помощью хука useRouteError и отображали на странице текст ошибки из выброса
можно на родительский элемент повесить данный компонент с errorElement={<ErrorPage />}
и тогда до загрузки родительского роута будет выдаваться ошибка
если повесить errorElement={<ErrorPage />} в корневой, то до загрузки всего дерева роута будет выдаваться ошибка. 

то есть тут
<Route path="/" element={<Layout />} errorElement={<ErrorPage />}>
если ошибка будет в Layout, то отрисуется содержимое errorElement
если errorElement идет на родителя, то родитель также не отрисовывается
то есть в этом случае вообще ничего не отрисуется, а не только Blogpage.

А мы хотели чтобы ошибка просто была на всех роутах, а база Layout рисовалась
либо можно в компоненте errorElement все воссоздать для отрисовки Layout, но это кажется сложным
уберем условие в функции getPosts
и добавим проверку в функцию blogLoader
импортируем метод json из react-router-dom
и будем кидать ошибку через метод json из react-router-dom
json удален из react-router-dom!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

не работает условие 
if (!posts.length) {
		throw data({message: 'not found', reason: 'неправильная ссылка'}, {status: 404})
	}
оно всегда тру в любом случае

добавил await тут: const posts = await getPosts()
помогло
теперь появляется длинна массива, вместо Promise. 

нужно вместо него использовать метод data, используется точно также
if (!posts.length) {
		throw json({message: 'not found', reason: 'неправильная ссылка'}, {status: 404})
	}
в первом параметре будет объект с любым набором данных. в нашем случае:
message: 'not found'. Это типа переменная с названием message и значеним 'not found'
и объект reason: 'неправильная ссылка'
и второй параметр status там вручную укажем значение 404
в этом случае в файл ErrorPage мы обращаемся в параметру 
<h2>{error.data || 'ТУТ ОШИБКА!'}</h2>
в дате будет то, что мы указали в первом параметре при выбросе json:
{message: 'not found', reason: 'неправильная ссылка'}

и пропишем это в ErrorPage.jsx
<h1>{error.status}</h1>
<h2>{error.data.message || 'ТУТ ОШИБКА!'}</h2>
<h3>{error.data.reason</h3>
обратились через data к нашему первому параметру выбрасываемого json из функции blogLoader в файле Blogpage.jsx

еще есть возможность првоерить ошибка связана с роутингом или нет
напишем условие
if (isRouteErrorResponse(error)) {
		return (
		<div>
			<h1>{error.status}</h1>
			{/*<h2>{error.statusText || 'неверно прописали выброс респонсе!'}</h2>*/}
			<h2>{error.data.message || 'ТУТ ОШИБКА!'}</h2>
			<h3>{error.data.reason}</h3>
		</div>
		)

в нем мы проверяем на уровне роутинга ошибка или нет
а если условие не сработало, функция вернула фолз при проверке ошибки в роутинге она или нет, то просто кидаем ошибку:
throw error
либо можно возвращать и другую разметку
также можно проверять на статусы кодов с ошибками
404 401 503 и тд





ИНТЕРЦЕПТОРЫ в Axios!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
видео: https://www.youtube.com/watch?v=h1zzVehQnyQ
сначала нужно создать объект axios
пишем:
api = axios.create();
теперь можно вместо axios импользовать объект api, и писать с помощью него запросы. Это будет тоже самое. Но к нему можно добавить интерцепторы, это такие перехватчики - interceptors, которые выполняют дополнительные действия в момент запроса - request или ответа - response 
interceptors - выполняют доп действия, прежде чем запрос достигнет своей цели
структура:
api.interceptors.request.use(первая функция в случае успеха, вторая функция в случае ошибки)
первая функция срабатывает во время запроса, вторая срабатывает когда есть какая либо ошибка на фронте
обычно там используют стрелочные функции
теперь вместо axios можно использовать объект api, и с помощью него вызывать пост и гет запросы
и при запросах будут срабатывать интерцепторы
но функция из ошибки будет срабатывать только тогда, когда проблема с клиентской частью, и не при запросе с бэка
Первая функция в интерцепторе это и есть переменные когда мы прокидвали как параметры при пост запросе в фигурных скобках. 
Параметр этой стрелочной функции это и есть тело запроса. Там мы в headers можем прокидывать объект авторизации с токеном: {Authorization: "значение токена"}. 
api.interceptors.request.use(	
	(config) => {
		if (Cookies.get("Authorization")) {
			config.headers.Authorization = `Bearer ${Cookies.get("Authorization")}`
		}
		
		return config;
	},
	(error) => {
		console.log(error)
	}
)

вместо Cookies.get("Authorization") можно писать и что либо другое, если в локальном хранилище хранится токен или если через переменную туда подставляем и тд
config обязательно нужно возвращать в первой функции

и теперь нужно еще настроить ответ от сервера - response!!!!!!!!!!!!!!!!!!!!!!
api.interceptors.response.use(первая функция, вторая функция)
первая срабатывает во время ответа, вторая срабатывает когда происходит ошибка на при ответе с бэка. ТО есть тут можно ловить ошибки с бэка!!!!!!!!!!!!!!
Конструкция:
api.interceptors.response.use(
	(config) => {
		if (Cookies.get("Authorization")) {
			config.headers.Authorization = `Bearer ${Cookies.get("Authorization")}`
		}
		return config;
	},
	(error) => {
		console.log(error)
	}
)

также как в гпт, в request нужно сначала сделать проверку есть ли токен в куках на фронте, если он есть, то тогда потом его кидать в запрос. Если нет, не кидать соответственно, и его не будет при запросе. 
в response сделать такую же проверку

в простом случае мы делали бы перенаправление на страницу логин. Но в нашем случае нужно сделать автоматическое обновление аксес токена по рефрешу. 
также в интерцепторе response в функции по обработке ошибки, можно прописать логику обработки ошибки. Например, обновление аксес токена по рефрешу. Затем нужно сделать повторный запрос, который привел к ошибке, но уже с новым токеном. Далее если рефреш токен также истек, то нужна переадресация на страницу ввода логи и пароля

также этот объект с интерцепторами лучше вынести в отдельный файл. И из него экспортировать. Потом юзать в других файлах, вместо axios писать api то есть переменную с объектом axios в которой прописаны интерцепторы. 

сделать интерцепторы в проекте!!!!!!!!!!!!!!
пока сделал только файл в папке api
к защищенным эндпоинтам обращаться через объект API с интерцептором, а к не защищенным эндпоинтам обращаться через обычный axios
Как сделать перехватчик(interceptor) в axios на react?
https://qna.habr.com/q/919369



клиент то есть реакт отправляет client id и client secret на бэкенд то есть в фастапи
бэкенд все проверяет и отправляет acces токен



ссылка на урок пагинации: https://www.youtube.com/watch?v=jBAGz_mUqew
тоже пройти потом



